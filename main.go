package main

//go:generate go run main.go --pkg tests --skip-hidden --src . --dst tests/dir.go tests/dir.go tests/dir2.go
//go:generate go run main.go --pkg tests --skip-hidden --src . --dst tests/dir2.go --name Second tests/dir.go tests/dir2.go
//go:generate go run main.go --pkg tests --skip-hidden --src go.mod --dst tests/file.go
//go:generate go run main.go --pkg tests --skip-hidden --src empty --dst tests/empty.go --name Empty

import (
	"encoding/base64"
	"fmt"
	"io"
	"io/ioutil"
	"os"
	"path"
	"path/filepath"
	"strings"
	"text/template"
	"time"

	"github.com/golang/snappy"
	"github.com/nikandfor/cli"
	"github.com/pkg/errors"
)

type file struct {
	Path    string
	Size    int64
	ModTime time.Time
	Files   []string
	Content string
	Mode    os.FileMode
	IsDir   bool
}

func main() {
	cli.App = cli.Command{
		Name:   "embed",
		Action: embed,
		Flags: []*cli.Flag{
			cli.NewFlag("src,s", "static", "folder of file to embed"),
			cli.NewFlag("dst,d", "static/embedded.go", "output file"),
			cli.NewFlag("package,pkg,p", "static", "package name"),
			cli.NewFlag("name,n", "", "prefix all functions with given name"),
			cli.NewFlag("skip-hidden,h", false, "skip hidden files in src"),
			cli.NewFlag("trim-prefix,prefix", "", "trim prefix in each path"),
			cli.NewFlag("force-structs", false, "add struct definitions even with given name"),
		},
	}

	cli.RunAndExit(os.Args)
}

func embed(c *cli.Command) error {
	stat, err := os.Stat(c.String("src"))
	if err != nil {
		return err
	}
	if !stat.IsDir() {
		return embedFile(c)
	}

	var files []*file
	dirs := map[string]*file{}

	err = filepath.Walk(c.String("src"), func(p string, info os.FileInfo, err error) error {
		if p == path.Clean(c.String("dst")) {
			return nil
		}
		for _, a := range c.Args {
			if p == filepath.Clean(a) {
				return nil
			}
		}

		realPath := p
		if pp := c.String("trim-prefix"); pp != "" {
			if strings.HasPrefix(p, pp) {
				p = p[len(pp):]
			} else {
				return fmt.Errorf("path %v does not have prefix %v", p, pp)
			}
		}
		for strings.HasPrefix(p, "../") {
			p = p[3:]
		}
		if p == "" || p == ".." {
			p = "."
		}
		if p[0] == '/' {
			p = p[1:]
		}

		if c.Bool("skip-hidden") {
			n := path.Base(p)
			if n != "." && n[0] == '.' {
				if info.IsDir() {
					return filepath.SkipDir
				}
				return nil
			}
		}

		f := &file{
			Path:    p,
			Size:    info.Size(),
			Mode:    info.Mode(),
			ModTime: info.ModTime(),
			IsDir:   info.IsDir(),
		}

		files = append(files, f)

		if info.IsDir() {
			dirs[p] = f
		} else {
			data, err := ioutil.ReadFile(realPath)
			if err != nil {
				return errors.Wrap(err, "read src file")
			}

			if len(data) != 0 {
				z := snappy.Encode(nil, data)
				a := base64.StdEncoding.EncodeToString(z)

				f.Content = a
			}
		}

		if d, fn := path.Split(p); fn != "." {
			if d == "" {
				d = "."
			}
			if l := len(d) - 1; d[l] == '/' {
				d = d[:l]
			}
			dirs[d].Files = append(dirs[d].Files, fn)
		}

		return nil
	})
	if err != nil {
		return errors.Wrap(err, "walk src")
	}

	var w io.Writer = os.Stdout
	if q := c.String("dst"); q != "-" {
		f, err := os.Create(q)
		if err != nil {
			return errors.Wrap(err, "create dst")
		}
		defer f.Close()

		w = f
	}

	t := template.New("")
	t.Funcs(template.FuncMap{
		"sprintf": fmt.Sprintf,
	})
	t = template.Must(t.Parse(`// Generated by {{ .generator }}. DO NOT EDIT.

package {{ .package }}

{{ if and .name (not .forceStructs) -}}
import (
	"net/http"
	"time"
)
{{- else -}}
import (
	"bytes"
	"encoding/base64"
	"errors"
	"io"
	"net/http"
	"os"
	"path"
	"sync"
	"time"

	"github.com/golang/snappy"
)

type (
	file struct {
		path    string
		size    int64
		modTime time.Time
		mode    os.FileMode
		isDir   bool

		files   []string
		content string

		once    sync.Once
		decoded []byte
	}

	fs struct {
		m     map[string]*file
		index bool
	}

	fsfile struct {
		r bytes.Reader
		*file
		fs
		d int
	}
)

var timeFormat = "2006-01-02 15:04:05.999999999 -0700 MST"

var (
	ErrClosed     = errors.New("closed file")
	ErrOutOfRange = errors.New("out of range")
)
{{- end }}

func {{ .name }}FS(index bool) http.FileSystem {
	return fs{
		m:     m{{ .name }},
		index: index,
	}
}

{{ if or .forceStructs (not .name) -}}
func (fs fs) Open(p string) (_ http.File, err error) {
	if len(p) != 0 && p[0] == '/' {
		p = p[1:]
	}
	if p == "" {
		p = "."
	}
	f, ok := fs.m[p]
	if !ok {
		return nil, os.ErrNotExist
	}

	f.once.Do(func() {
		if f.content == "" {
			return
		}

		var z []byte
		z, err = base64.StdEncoding.DecodeString(f.content)
		if err != nil {
			return
		}

		f.decoded, err = snappy.Decode(nil, z)
	})
	if err != nil {
		return
	}

	ff := &fsfile{file: f, fs: fs}
	ff.r.Reset(f.decoded)

	return ff, nil
}

func (f *fsfile) Close() error { f.d = -1; return nil }

func (f *fsfile) Seek(off int64, whence int) (int64, error) {
	if f.d == -1 {
		return 0, ErrClosed
	}
	return f.r.Seek(off, whence)
}

func (f *fsfile) Read(p []byte) (n int, err error) {
	if f.d == -1 {
		return 0, ErrClosed
	}
	return f.r.Read(p)
}

func (f *fsfile) ReadAt(p []byte, off int64) (n int, err error) {
	if f.d == -1 {
		return 0, ErrClosed
	}
	return f.r.ReadAt(p, off)
}

func (f *fsfile) Stat() (os.FileInfo, error) {
	return f.file, nil
}

func (f *fsfile) Readdir(n int) ([]os.FileInfo, error) {
	if !f.fs.index {
		return nil, nil
	}

	var res []os.FileInfo
	for f.d < len(f.files) && len(res) < n {
		res = append(res, m[path.Join(f.path, f.files[f.d])])
		f.d++
	}

	if f.d == len(f.files) {
		return res, io.EOF
	}

	return res, nil
}

func (f *file) Name() string       { return path.Base(f.path) }
func (f *file) Size() int64        { return f.size }
func (f *file) Mode() os.FileMode  { return f.mode }
func (f *file) ModTime() time.Time { return f.modTime }
func (f *file) IsDir() bool        { return f.isDir }
func (f *file) Sys() interface{}   { return nil }

func must(t time.Time, err error) time.Time {
	if err != nil {
		panic(err)
	}
	return t
}

{{ end -}}
var m{{ .name }} = map[string]*file{
{{- range .files }}
	` + "`{{ .Path }}`" + `: {
		path:    ` + "`{{ .Path }}`" + `,
		size:    {{ .Size }},
		mode:    {{ .Mode | sprintf "0%o" }},
		modTime: must(time.Parse(timeFormat, "{{ .ModTime }}")),
		{{- if .IsDir }}
		isDir:   {{ .IsDir }},
		files:   []string{
		{{- range $i, $e := .Files }}{{ if $i }}, {{ end }}` + "`{{ . }}`" + `{{ end }}},
		{{- end }}
		{{- with .Content }}
		content: ` + "`{{ . }}`" + `,{{ end }}
	},
{{- end }}
}` + "\n"))

	err = t.Execute(w, map[string]interface{}{
		"generator":    "embed",
		"package":      c.String("package"),
		"name":         c.String("name"),
		"files":        files,
		"forceStructs": c.Bool("force-structs"),
	})
	if err != nil {
		return errors.Wrap(err, "template")
	}

	return nil
}

func embedFile(c *cli.Command) error {
	data, err := ioutil.ReadFile(c.String("src"))
	if err != nil {
		return errors.Wrap(err, "read src")
	}

	var cont string
	if len(data) != 0 {
		z := snappy.Encode(nil, data)
		cont = base64.StdEncoding.EncodeToString(z)
	}

	var w io.Writer = os.Stdout
	if q := c.String("dst"); q != "-" {
		f, err := os.Create(q)
		if err != nil {
			return errors.Wrap(err, "create dst")
		}
		defer f.Close()

		w = f
	}

	t := template.Must(template.New("").Parse(`// Generated by {{ .generator }}. DO NOT EDIT.

package {{ .package }}

import (
	"bytes"
{{- if .content }}
	"encoding/base64"
	"io"
	"io/ioutil"

	"github.com/golang/snappy"
{{ else }}
	"io"
{{ end -}}
)

func {{ .name }}Reader() io.Reader {
{{- if .content }}
	z, err := base64.StdEncoding.DecodeString(c{{ .name }})
	if err != nil {
		panic(err)
	}
	r, err := snappy.Decode(nil, z)
	if err != nil {
		panic(err)
	}
	return bytes.NewReader(r)
{{ else }}
	return bytes.NewReader(nil)
{{ end -}}
}

func {{ .name }}ReadAll() []byte {
{{- if .content }}
	data, err := ioutil.ReadAll({{ .name }}Reader())
	if err != nil {
		panic(err)
	}
	return data
{{ else }}
	return nil
{{ end -}}
}

var c{{ .name }} = ` + "`{{ .content }}`\n"))

	err = t.Execute(w, map[string]interface{}{
		"generator": "embed",
		"package":   c.String("package"),
		"name":      c.String("name"),
		"content":   cont,
	})
	if err != nil {
		return errors.Wrap(err, "template")
	}

	return nil
}
